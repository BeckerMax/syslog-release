$ModLoad imuxsock                       # local message reception (rsyslog uses a datagram socket)
$MaxMessageSize 4k                      # default is 2k
$WorkDirectory /var/vcap/data/syslog_forwarder/buffered # where messages should be buffered on disk

# Forward vcap messages to the aggregator

<% if p('fallback_addresses').length > 0 %>
$ActionResumeRetryCount 2              # Try with a fallback server after 2 retries
$ActionQueueType Direct
<% else %>
$ActionResumeRetryCount -1             # Try until the server becomes available
$ActionQueueType LinkedList            # Allocate on-demand
<% end %>

$ActionQueueFileName agg_backlog        # Spill to disk if queue is full
$ActionQueueMaxDiskSpace 32m            # Max size for disk queue
$ActionQueueLowWaterMark 2000           # Num messages. Assuming avg size of 512B, this is 1MiB.
$ActionQueueHighWaterMark 8000          # Num messages. Assuming avg size of 512B, this is 4MiB. (If this is reached, messages will spill to disk until the low watermark is reached).
$ActionQueueTimeoutEnqueue 0            # Discard messages if the queue + disk is full
$ActionQueueSaveOnShutdown on           # Save in-memory data to disk if rsyslog shuts down

# Listen for logs over UDP
#
$ModLoad imudp
$UDPServerAddress 127.0.0.1
$UDPServerRun 514


template(name="BoshLogTemplate" type="list") {
constant(value="<")
property(name="pri")
constant(value=">")
property(name="timestamp" dateFormat="rfc3339")
constant(value=" <%= spec.address %> ")
property(name="programname")
constant(value=" <%= spec.job.name %>/<%= spec.id %> ")
property(name="msg")
}

<%= p('custom_rule') %>

<% if p('tls_enabled') %>
  <% ca_cert_path = '/etc/ssl/certs/ca-certificates.crt'

  if_p('ca_cert') do
    ca_cert_path = '/var/vcap/jobs/syslog_forwarder/config/ca_cert.pem'
  end %>

$DefaultNetstreamDriverCAFile <%= ca_cert_path %> # trust these CAs
$ActionSendStreamDriver gtls # use gtls netstream driver
$ActionSendStreamDriverMode 1 # require TLS
$ActionSendStreamDriverAuthMode x509/name # authenticate by hostname
$ActionSendStreamDriverPermittedPeer <%= p('permitted_peer') %>
<% end %>

<%
syslog_transport = nil
syslog_address = nil
syslog_port = nil

if_link('syslog_storer') do |syslog_storer|
  syslog_address = syslog_storer.instances[0].address
  syslog_port = syslog_storer.p('port')
  syslog_transport = syslog_storer.p('transport')
end %>

<% if_p('destination_address', 'destination_port', 'destination_transport') do |address, port, transport|
  syslog_address = address
  syslog_port = port
  syslog_transport = transport
end %>

<% if syslog_transport == 'relp' %>
$ModLoad omrelp
*.* :omrelp:<%= syslog_address %>:<%= syslog_port %>;BoshLogTemplate
<% elsif syslog_transport == 'udp' %>
*.* @<%= syslog_address %>:<%= syslog_port %>;BoshLogTemplate
<% elsif syslog_transport == 'tcp' %>
*.* @@<%= syslog_address %>:<%= syslog_port %>;BoshLogTemplate
<% else %>
<% raise 'only RELP, UDP, and TCP are supported' %>
<% end %>

<% if p('fallback_addresses').length > 0 %>
$ActionExecOnlyWhenPreviousIsSuspended on
    <% p('fallback_addresses', []).each do |fallback_address| %>
        <%
          syslog_fallback_address = fallback_address['address']
          syslog_fallback_port = fallback_address['port']
          syslog_fallback_transport = fallback_address['transport']
        %>
        <% if syslog_fallback_transport == 'relp' %>
$ModLoad omrelp
:omrelp:<%= syslog_fallback_address %>:<%= syslog_fallback_port %>;BoshLogTemplate
        <% elsif syslog_fallback_transport == 'tcp' %>
& @@<%= syslog_fallback_address %>:<%= syslog_fallback_port %>;BoshLogTemplate
        <% else %>
            <%raise 'only RELP, and TCP are supported for failover' %>
        <% end %>
    <% end %>
$ActionExecOnlyWhenPreviousIsSuspended off
<% end %>

# Prevent them from reaching anywhere else
:programname, startswith, "vcap." ~
